---
phase: 01-foundation-authentication
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/secrets/keyring.go
  - internal/secrets/file.go
  - internal/secrets/detect.go
  - internal/auth/flows.go
  - internal/auth/server.go
  - internal/auth/token.go
  - internal/auth/scopes.go
autonomous: true

must_haves:
  truths:
    - "OS keyring stores and retrieves refresh tokens on supported platforms (macOS, Linux with Secret Service, Windows)"
    - "Encrypted file fallback stores credentials when keyring unavailable (WSL, headless, Docker)"
    - "OAuth2 interactive flow opens browser, receives callback on localhost, exchanges code for tokens"
    - "Manual paste flow works without browser (prints URL, accepts pasted redirect URL)"
    - "Token cache with file locking prevents concurrent refresh stampede"
    - "Access tokens auto-refresh transparently when expired or within 5-minute proactive window"
  artifacts:
    - path: "internal/secrets/keyring.go"
      provides: "OS keyring implementation of Store interface using 99designs/keyring"
      contains: "keyring.Open"
    - path: "internal/secrets/file.go"
      provides: "AES-256-GCM encrypted file implementation of Store interface"
      contains: "cipher.NewGCM"
    - path: "internal/secrets/detect.go"
      provides: "Platform detection and automatic Store selection (keyring vs file fallback)"
      contains: "NewStore"
    - path: "internal/auth/flows.go"
      provides: "Interactive and manual OAuth2 login flows"
      exports: ["InteractiveLogin", "ManualLogin"]
    - path: "internal/auth/server.go"
      provides: "Temporary localhost HTTP server for OAuth2 callback"
      contains: "ListenAndServe"
    - path: "internal/auth/token.go"
      provides: "Token cache with file locking implementing oauth2.TokenSource"
      contains: "flock"
  key_links:
    - from: "internal/auth/flows.go"
      to: "internal/auth/server.go"
      via: "Interactive flow starts callback server"
      pattern: "startCallbackServer"
    - from: "internal/auth/token.go"
      to: "internal/secrets/store.go"
      via: "Token cache reads/writes refresh token to secrets Store"
      pattern: "store\\.(Get|Set)"
    - from: "internal/auth/token.go"
      to: "gofrs/flock"
      via: "File locking on token cache to prevent concurrent refresh"
      pattern: "flock\\.New"
    - from: "internal/secrets/detect.go"
      to: "internal/secrets/keyring.go"
      via: "NewStore tries keyring first, falls back to file"
      pattern: "NewKeyringStore|NewFileStore"
---

<objective>
Implement the credential storage layer (OS keyring + encrypted file fallback) and OAuth2 authentication flows (interactive browser-based + manual paste). Build the file-locked token cache that auto-refreshes access tokens transparently.

Purpose: Authentication is the gatekeeper for every Zoho API call. Secure credential storage and race-condition-free token refresh are non-negotiable for a production CLI. This plan creates the auth engine that Plan 03 wires into CLI commands.
Output: Working secrets store (keyring + fallback), OAuth2 flows that produce tokens, and a file-locked token cache implementing oauth2.TokenSource.
</objective>

<execution_context>
@/home/semmy/.claude/get-shit-done/workflows/execute-plan.md
@/home/semmy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Secrets store -- keyring backend and encrypted file fallback</name>
  <files>
    internal/secrets/keyring.go
    internal/secrets/file.go
    internal/secrets/detect.go
  </files>
  <action>
1. Create `internal/secrets/keyring.go` -- OS keyring implementation:
   - `KeyringStore` struct wrapping `keyring.Keyring` from `99designs/keyring`
   - `NewKeyringStore() (*KeyringStore, error)` -- opens keyring with config:
     ```go
     keyring.Config{
         ServiceName:             "zoh",
         KeychainTrustApplication: true,       // macOS: don't prompt every access
         FileDir:                 filepath.Join(xdg.DataHome, "zoh", "keyring"),
         FilePasswordFunc:        keyring.TerminalPrompt,
     }
     ```
   - Implements `Store` interface (Get, Set, Delete, List)
   - `Get(key)` -> `ring.Get(key)`, map keyring.ErrKeyNotFound to secrets.ErrNotFound
   - `Set(key, value)` -> `ring.Set(keyring.Item{Key: key, Data: []byte(value)})`
   - `Delete(key)` -> `ring.Remove(key)`
   - `List()` -> `ring.Keys()`

2. Create `internal/secrets/file.go` -- Encrypted file fallback:
   - `FileStore` struct with `path string` (in XDG data dir), `key []byte` (derived from password)
   - `NewFileStore(password string) (*FileStore, error)`:
     - Path: `filepath.Join(xdg.DataHome, "zoh", "credentials.enc")`
     - Derive 32-byte key from password using `crypto/sha256` (simple for v1; scrypt would be better but adds complexity -- note this in code comment as future improvement)
     - If password is empty, use a machine-specific default (hostname + username hash) with a warning printed to stderr that this is less secure
   - Internal storage: JSON map `map[string]string` encrypted with AES-256-GCM
   - `Get(key)` -> decrypt file, parse JSON map, return value or ErrNotFound
   - `Set(key, value)` -> decrypt file (or start with empty map), set key, re-encrypt, write with 0600 perms
   - `Delete(key)` -> decrypt, delete key, re-encrypt, write
   - `List()` -> decrypt, return map keys
   - Encryption helpers:
     - `encrypt(plaintext, key []byte) ([]byte, error)` -- AES-256-GCM with random 12-byte nonce prepended
     - `decrypt(ciphertext, key []byte) ([]byte, error)` -- extract nonce, decrypt remainder
   - Create parent directory with 0700 permissions if missing

3. Create `internal/secrets/detect.go` -- Platform detection and auto-selection:
   - `NewStore() (Store, error)`:
     - Check if on WSL: read `/proc/version`, look for "microsoft" or "WSL" (case-insensitive)
     - Check if headless: `os.Getenv("DISPLAY") == "" && os.Getenv("WAYLAND_DISPLAY") == ""` on Linux
     - If WSL or headless → skip keyring, use FileStore directly with machine-specific default key
     - Otherwise → try `NewKeyringStore()`. If error → fall back to FileStore with warning to stderr
   - `IsWSL() bool` -- exported helper for other packages
   - `IsHeadless() bool` -- exported helper

4. Run `go mod tidy` after adding 99designs/keyring dependency.
  </action>
  <verify>
Run: `cd /home/semmy/codeprojects/zohod-cli && go build ./...`
Expected: All three files compile. Store interface satisfied by both KeyringStore and FileStore.
Run: `go vet ./internal/secrets/...` -- no errors.
  </verify>
  <done>
- KeyringStore wraps 99designs/keyring and implements Store interface
- FileStore uses AES-256-GCM encryption and implements Store interface
- NewStore() auto-detects platform (WSL, headless) and selects appropriate backend
- Both stores handle Get/Set/Delete/List with proper error handling
- `go build ./...` passes clean
  </done>
</task>

<task type="auto">
  <name>Task 2: OAuth2 flows, localhost callback server, and file-locked token cache</name>
  <files>
    internal/auth/flows.go
    internal/auth/server.go
    internal/auth/token.go
    internal/auth/scopes.go
  </files>
  <action>
1. Create `internal/auth/scopes.go` -- OAuth2 scope definitions:
   - Define scope constants for all Zoho services used in v1:
     ```go
     var DefaultScopes = []string{
         "ZohoMail.messages.ALL",
         "ZohoMail.folders.ALL",
         "ZohoMail.accounts.READ",
         "ZohoMail.organization.accounts.READ",
         "ZohoAdmin.orgs.ALL",
     }
     ```
   - `ScopeString() string` -- joins scopes with comma (Zoho uses comma separator, not space)
   - Note: Zoho uses comma-separated scopes in the auth URL, not space-separated like standard OAuth2. The golang.org/x/oauth2 library uses space by default, so scopes must be joined manually in the auth URL or handled via a custom parameter.

2. Create `internal/auth/server.go` -- Localhost callback HTTP server:
   - `callbackResult` struct: `Code string`, `State string`, `Error string`
   - `startCallbackServer(ctx context.Context, port int) (resultChan chan callbackResult, addr string, shutdown func())`:
     - Default port 8080, configurable
     - Register handler on `/callback` that extracts `code` and `state` query params
     - On success: send result to channel, render "Authentication successful! You can close this window." HTML page
     - On error (missing code): send error result, render error HTML page
     - Return channel, callback URL string (`http://localhost:{port}/callback`), and shutdown function
     - Server auto-shuts down after receiving one callback or on context cancellation
     - Use `net.Listen("tcp", ":0")` pattern to find available port if 8080 is taken, then extract actual port from listener

3. Create `internal/auth/flows.go` -- OAuth2 login flows:
   - Store oauth2 config builder:
     ```go
     func newOAuth2Config(cfg *config.Config, redirectURL string) *oauth2.Config {
         region := config.GetRegion(cfg.Region)
         return &oauth2.Config{
             ClientID:     cfg.ClientID,
             ClientSecret: cfg.ClientSecret,
             Endpoint: oauth2.Endpoint{
                 AuthURL:  region.AccountsServer + "/oauth/v2/auth",
                 TokenURL: region.AccountsServer + "/oauth/v2/token",
             },
             RedirectURL: redirectURL,
         }
     }
     ```
   - **Zoho-specific token exchange:** Zoho's token endpoint does NOT follow standard OAuth2 response format. The access token response includes `api_domain` and `token_type` fields but may return errors in a non-standard way. Wrap the oauth2.Config.Exchange call and handle Zoho-specific error responses (e.g., `{"error": "invalid_code"}`).

   - `InteractiveLogin(ctx context.Context, cfg *config.Config) (*oauth2.Token, error)`:
     - Start callback server
     - Build auth URL with scopes (join with comma for Zoho), state parameter, access_type=offline, prompt=consent
     - Note: Zoho requires `access_type=offline` to get a refresh token and may require `prompt=consent` to force refresh token issuance
     - Open browser via `pkg/browser`
     - Print auth URL to stderr as fallback (in case browser doesn't open)
     - Wait for callback with 5-minute timeout
     - Exchange code for tokens
     - Return token (contains access_token, refresh_token, expiry)

   - `ManualLogin(ctx context.Context, cfg *config.Config) (*oauth2.Token, error)`:
     - Build auth URL with redirect to `http://localhost:8080/callback` (user will paste the redirected URL)
     - Print auth URL to stderr, instruct user to visit it
     - Print: "After authorizing, paste the full redirect URL here:"
     - Read line from stdin
     - Parse pasted URL to extract `code` parameter
     - Exchange code for tokens
     - Return token

   - Both flows validate that config has ClientID and ClientSecret before starting (return CLIError with ExitConfigError if missing)

4. Create `internal/auth/token.go` -- File-locked token cache with auto-refresh:
   - `TokenCache` struct:
     ```go
     type TokenCache struct {
         cachePath   string        // XDG cache dir for access token
         lockPath    string        // .lock file path
         store       secrets.Store // For refresh token (long-lived)
         region      string        // Region code for this account
         clientID    string
         clientSecret string
         accountsURL string       // Region-specific accounts server
     }
     ```
   - `NewTokenCache(cfg *config.Config, store secrets.Store) *TokenCache`:
     - cachePath: `filepath.Join(xdg.CacheHome, "zoh", "token-{region}.json")`
     - lockPath: cachePath + ".lock"
     - Store refresh token key: `"refresh_token_{region}"`

   - Implement `oauth2.TokenSource` interface:
     ```go
     func (tc *TokenCache) Token() (*oauth2.Token, error)
     ```
     - Acquire file lock via `gofrs/flock` (blocking with 10-second timeout)
     - Read cached access token from cachePath
     - If valid AND expiry > 5 minutes away (proactive refresh window) → return cached token
     - If expired or within 5-min window → refresh:
       - Read refresh token from secrets store
       - POST to `{accountsURL}/oauth/v2/token` with grant_type=refresh_token
       - Parse response, extract new access_token (and optionally new refresh_token)
       - Write new access token to cache file (0600 perms)
       - If new refresh token returned, update secrets store
     - Release file lock
     - Handle errors: if refresh fails with `invalid_grant`, return CLIError with ExitAuth and hint "Run `zoh auth login` to re-authenticate"

   - `SaveInitialTokens(token *oauth2.Token) error`:
     - Called after login flow completes
     - Store refresh token in secrets store
     - Cache access token in file
     - Both operations under file lock

   - `ClearTokens() error`:
     - Called by logout
     - Delete refresh token from secrets store
     - Delete cache file
     - Delete lock file

   - Cache file format: JSON with `access_token`, `token_type`, `expiry` (RFC3339)
   - Create cache directory with 0700 if missing

5. Run `go mod tidy` after adding gofrs/flock, pkg/browser dependencies.
  </action>
  <verify>
Run: `cd /home/semmy/codeprojects/zohod-cli && go build ./...`
Expected: All auth and secrets packages compile. TokenCache implements oauth2.TokenSource interface.
Run: `go vet ./internal/auth/... ./internal/secrets/...` -- no errors.
Verify: TokenCache struct has `Token() (*oauth2.Token, error)` method (satisfies oauth2.TokenSource).
  </verify>
  <done>
- InteractiveLogin opens browser, receives callback, exchanges code for tokens
- ManualLogin prints URL, reads pasted redirect, exchanges code for tokens
- TokenCache implements oauth2.TokenSource with file locking (gofrs/flock)
- Proactive refresh when token within 5 minutes of expiry
- Refresh token stored in secrets Store (keyring or encrypted file)
- Access token cached in XDG cache dir as JSON
- SaveInitialTokens and ClearTokens for login/logout lifecycle
- `go build ./...` passes clean
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` -- all packages compile
2. `go vet ./...` -- no warnings
3. KeyringStore and FileStore both satisfy secrets.Store interface
4. TokenCache satisfies oauth2.TokenSource interface
5. File locking uses gofrs/flock (not manual flock syscalls)
6. Interactive and manual login flows both produce *oauth2.Token
7. WSL detection reads /proc/version for "microsoft"
8. Encrypted file uses AES-256-GCM (not AES-CBC or other modes)
</verification>

<success_criteria>
- Secrets store with OS keyring and encrypted file fallback compiles
- Platform detection correctly identifies WSL and headless environments
- OAuth2 interactive flow (browser + localhost callback) implemented
- OAuth2 manual flow (paste URL) implemented
- File-locked token cache prevents concurrent refresh stampede
- Proactive token refresh within 5-minute window
- All packages compile and pass go vet
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-02-SUMMARY.md`
</output>
