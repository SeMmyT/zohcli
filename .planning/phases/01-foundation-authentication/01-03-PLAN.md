---
phase: 01-foundation-authentication
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - internal/zoho/client.go
  - internal/zoho/ratelimit.go
  - internal/cli/auth.go
  - internal/cli/configcmd.go
  - internal/cli/cli.go
  - main.go
autonomous: true

must_haves:
  truths:
    - "User can run `zoh auth login` and complete interactive OAuth2 flow with browser callback"
    - "User can run `zoh auth login --manual` and complete manual paste flow without browser"
    - "User can run `zoh auth logout` to remove stored credentials"
    - "User can run `zoh auth list` to see stored accounts and `zoh auth list --check` to validate tokens"
    - "User can run `zoh config get/set/unset/list/path` to manage configuration"
    - "HTTP client resolves region-specific base URLs and attaches OAuth2 bearer tokens"
    - "Rate limiter enforces 25 req/min budget (under 30 req/min Zoho limit) with exponential backoff on 429"
    - "All commands output correctly in JSON, plain, and rich modes"
  artifacts:
    - path: "internal/zoho/client.go"
      provides: "Region-aware HTTP client with OAuth2 transport"
      contains: "oauth2.Transport"
    - path: "internal/zoho/ratelimit.go"
      provides: "Token bucket rate limiter respecting Zoho's 30 req/min limit"
      contains: "rate.NewLimiter"
    - path: "internal/cli/auth.go"
      provides: "Auth CLI commands: login, logout, list"
      contains: "LoginCmd"
    - path: "internal/cli/configcmd.go"
      provides: "Config CLI commands: get, set, unset, list, path"
      contains: "ConfigGetCmd"
  key_links:
    - from: "internal/cli/auth.go"
      to: "internal/auth/flows.go"
      via: "Login command calls InteractiveLogin or ManualLogin"
      pattern: "auth\\.(Interactive|Manual)Login"
    - from: "internal/cli/auth.go"
      to: "internal/auth/token.go"
      via: "Login saves tokens, logout clears tokens, list reads tokens"
      pattern: "tokenCache\\.(SaveInitialTokens|ClearTokens|Token)"
    - from: "internal/zoho/client.go"
      to: "internal/auth/token.go"
      via: "HTTP client uses TokenCache as oauth2.TokenSource for automatic bearer token injection"
      pattern: "oauth2\\.NewClient|oauth2\\.Transport"
    - from: "internal/zoho/client.go"
      to: "internal/zoho/ratelimit.go"
      via: "HTTP client wraps transport with rate limiter"
      pattern: "rateLimiter\\.Wait"
    - from: "internal/cli/configcmd.go"
      to: "internal/config/config.go"
      via: "Config commands call Config.Get/Set/Unset/Save"
      pattern: "cfg\\.(Get|Set|Unset|Save)"
---

<objective>
Wire everything together: build the region-aware HTTP client with rate limiting, implement the auth CLI commands (login/logout/list with --check), and implement the config CLI commands (get/set/unset/list/path). After this plan, users can authenticate with Zoho and manage their CLI configuration.

Purpose: This is the integration plan that turns standalone modules (config, auth, secrets, output) into a working CLI. Without it, the infrastructure from Plans 01 and 02 remains disconnected library code.
Output: Fully functional `zoh auth login/logout/list` and `zoh config get/set/unset/list/path` commands backed by the OAuth2 engine, keyring storage, rate limiter, and output formatters.
</objective>

<execution_context>
@/home/semmy/.claude/get-shit-done/workflows/execute-plan.md
@/home/semmy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md
@.planning/phases/01-foundation-authentication/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Region-aware HTTP client with rate limiter</name>
  <files>
    internal/zoho/client.go
    internal/zoho/ratelimit.go
  </files>
  <action>
1. Create `internal/zoho/ratelimit.go` -- Client-side rate limiter:
   - Use `golang.org/x/time/rate` (standard library rate limiter) for token bucket
   - `NewRateLimiter() *rate.Limiter`:
     - 25 requests per 60 seconds (budget headroom under Zoho's 30 req/min limit)
     - Burst of 5 (allow small bursts for batch operations)
     - `rate.NewLimiter(rate.Every(time.Minute/25), 5)`
   - `RateLimitTransport` struct wrapping `http.RoundTripper`:
     - `limiter *rate.Limiter`
     - `backoff backoff.BackOff` (cenkalti/backoff v4 for exponential backoff on 429)
     - `RoundTrip(req *http.Request) (*http.Response, error)`:
       1. Call `limiter.Wait(req.Context())` -- blocks if rate limit exceeded
       2. Execute underlying transport
       3. If response status is 429:
          - Read Retry-After header if present, sleep that duration
          - Otherwise use exponential backoff (cenkalti/backoff)
          - Retry up to 3 times
       4. Return response

2. Create `internal/zoho/client.go` -- Region-aware API client:
   - `Client` struct:
     ```go
     type Client struct {
         httpClient  *http.Client
         region      config.RegionConfig
         rateLimiter *rate.Limiter
     }
     ```
   - `NewClient(cfg *config.Config, tokenSource oauth2.TokenSource) (*Client, error)`:
     - Get region config from `config.GetRegion(cfg.Region)`
     - Build transport chain:
       1. `http.DefaultTransport` (base)
       2. Wrap with `oauth2.Transport{Source: tokenSource}` (adds bearer token)
       3. Wrap with `RateLimitTransport` (enforces rate limit)
     - Set reasonable timeouts: 30s overall, 10s TLS handshake
     - Return Client with httpClient and region config

   - `Do(ctx context.Context, method, path string, body io.Reader) (*http.Response, error)`:
     - Resolve full URL: `c.region.APIBase + path`
     - Create request with context
     - Set Content-Type: application/json
     - Execute via httpClient.Do
     - Return response (caller is responsible for reading body and checking status)

   - `DoMail(ctx context.Context, method, path string, body io.Reader) (*http.Response, error)`:
     - Same as Do but uses `c.region.MailBase` as base URL
     - For mail-specific API calls (Phase 4+)

   - `DoAuth(ctx context.Context, method, path string, body io.Reader) (*http.Response, error)`:
     - Uses `c.region.AccountsServer` as base URL
     - For auth-related API calls (token introspect, etc.)
     - Does NOT add OAuth2 token (auth calls use different auth methods)

3. Run `go mod tidy` after adding golang.org/x/time/rate and cenkalti/backoff/v4.
  </action>
  <verify>
Run: `cd /home/semmy/codeprojects/zohod-cli && go build ./...`
Expected: zoho package compiles. Client struct created with all three Do methods.
Run: `go vet ./internal/zoho/...` -- no errors.
  </verify>
  <done>
- Rate limiter enforces 25 req/min with burst of 5
- RateLimitTransport handles 429 responses with exponential backoff
- Client resolves region-specific URLs (API, Mail, Accounts)
- OAuth2 transport injects bearer tokens automatically
- Transport chain: DefaultTransport -> OAuth2Transport -> RateLimitTransport
- `go build ./...` passes clean
  </done>
</task>

<task type="auto">
  <name>Task 2: Auth commands (login/logout/list) and config commands (get/set/unset/list/path)</name>
  <files>
    internal/cli/auth.go
    internal/cli/configcmd.go
    internal/cli/cli.go
    main.go
  </files>
  <action>
1. Create `internal/cli/auth.go` -- Auth command implementations:

   **AuthCmd** (already declared in cli.go from Plan 01, update to include subcommands):
   ```go
   type AuthCmd struct {
       Login  AuthLoginCmd  `cmd:"" help:"Log in to Zoho account"`
       Logout AuthLogoutCmd `cmd:"" help:"Log out and remove stored credentials"`
       List   AuthListCmd   `cmd:"" help:"List stored accounts"`
   }
   ```

   **AuthLoginCmd:**
   ```go
   type AuthLoginCmd struct {
       Manual bool   `help:"Manual paste mode (no browser)" short:"m"`
       Region string `help:"Override region for this login" enum:"us,eu,in,au,jp,ca,sa,uk"`
       Port   int    `help:"Callback server port" default:"8080"`
   }
   ```
   - `Run(cfg *config.Config, formatter output.Formatter) error`:
     1. Validate cfg.ClientID and cfg.ClientSecret exist (if not, print helpful error: "Run `zoh config set client_id YOUR_ID` and `zoh config set client_secret YOUR_SECRET` first, or see: https://api-console.zoho.com/")
     2. If --region flag set, override cfg.Region for this session
     3. Initialize secrets store via `secrets.NewStore()`
     4. If `--manual`: call `auth.ManualLogin(ctx, cfg)` to get token
     5. Else: call `auth.InteractiveLogin(ctx, cfg)` to get token
     6. Create TokenCache, call `SaveInitialTokens(token)`
     7. Save region to config if it was set via flag (persist the choice)
     8. Output success: formatter.Print with account info (region, scopes granted, token expiry)
     9. Print hint to stderr: "Authenticated successfully. Credentials stored in {keyring/file}."

   **AuthLogoutCmd:**
   ```go
   type AuthLogoutCmd struct {
       All bool `help:"Remove all stored accounts" short:"a"`
   }
   ```
   - `Run(cfg *config.Config, formatter output.Formatter) error`:
     1. Initialize secrets store and token cache
     2. If `--all`: clear all stored tokens (iterate regions)
     3. Else: clear tokens for current configured region only
     4. Print confirmation to stderr: "Logged out. Credentials removed."

   **AuthListCmd:**
   ```go
   type AuthListCmd struct {
       Check bool `help:"Validate stored tokens are still valid" short:"c"`
   }
   ```
   - `Run(cfg *config.Config, formatter output.Formatter) error`:
     1. Initialize secrets store
     2. List all stored refresh token keys (they follow pattern `refresh_token_{region}`)
     3. For each: extract region, determine if it's the active (configured) region
     4. If `--check`: attempt to get a valid access token for each, report valid/expired/error status
     5. Output as list: region, status (active/stored), valid (if --check), token expiry (if --check)
     6. Use formatter.PrintList with columns: Region, Status, Valid, Expiry

2. Create `internal/cli/configcmd.go` -- Config command implementations:

   **ConfigCmd** (update from Plan 01 stub):
   ```go
   type ConfigCmd struct {
       Get   ConfigGetCmd   `cmd:"" help:"Get a configuration value"`
       Set   ConfigSetCmd   `cmd:"" help:"Set a configuration value"`
       Unset ConfigUnsetCmd `cmd:"" help:"Remove a configuration value"`
       List  ConfigListCmd  `cmd:"" help:"List all configuration values"`
       Path  ConfigPathCmd  `cmd:"" help:"Show config file path"`
   }
   ```

   **ConfigGetCmd:**
   ```go
   type ConfigGetCmd struct {
       Key string `arg:"" help:"Config key to get (e.g., region, client_id)"`
   }
   ```
   - `Run(cfg *config.Config, formatter output.Formatter) error`:
     - Call cfg.Get(key), print value via formatter
     - If key not found, return CLIError with ExitNotFound

   **ConfigSetCmd:**
   ```go
   type ConfigSetCmd struct {
       Key   string `arg:"" help:"Config key to set"`
       Value string `arg:"" help:"Value to set"`
   }
   ```
   - `Run(cfg *config.Config, formatter output.Formatter) error`:
     - Validate key is a known config key
     - If key is "region", validate value is a valid region code
     - If key is "client_secret", suggest using secrets store instead (print hint to stderr), but allow it
     - Call cfg.Set(key, value), then cfg.Save()
     - Print confirmation to stderr: "Set {key} = {value}"

   **ConfigUnsetCmd:**
   ```go
   type ConfigUnsetCmd struct {
       Key string `arg:"" help:"Config key to remove"`
   }
   ```
   - `Run(cfg *config.Config, formatter output.Formatter) error`:
     - Call cfg.Unset(key), then cfg.Save()
     - Print confirmation to stderr

   **ConfigListCmd:** (no args)
   - `Run(cfg *config.Config, formatter output.Formatter) error`:
     - Output all config key-value pairs via formatter.PrintList
     - Mask sensitive values (client_secret) in output: show only last 4 chars

   **ConfigPathCmd:** (no args)
   - `Run(cfg *config.Config, formatter output.Formatter) error`:
     - Print config file path via formatter.Print
     - Print whether file exists as hint to stderr

3. Update `internal/cli/cli.go`:
   - Replace stub AuthCmd and ConfigCmd with the real implementations from auth.go and configcmd.go
   - Update BeforeApply hook to also initialize secrets.Store and auth.TokenCache, bind them to Kong context
   - Ensure formatter, config, store, and token cache are all available for injection into command Run methods

4. Update `main.go`:
   - Ensure error handling uses `output.ExitWithError` for proper exit codes
   - Handle kong parse errors (usage errors) with ExitUsage code
   - Handle Run errors: extract CLIError for specific exit codes, default to ExitGeneral

5. Run `go mod tidy` and `go build -o zoh ./...` to verify everything links.
  </action>
  <verify>
Run: `cd /home/semmy/codeprojects/zohod-cli && go build -o zoh ./...`
Expected: Binary compiles successfully.

Run: `./zoh --help`
Expected: Shows auth and config subcommands.

Run: `./zoh auth --help`
Expected: Shows login, logout, list subcommands with flags.

Run: `./zoh config --help`
Expected: Shows get, set, unset, list, path subcommands.

Run: `./zoh config path`
Expected: Prints XDG config path (e.g., ~/.config/zoh/config.json5).

Run: `./zoh config list --json`
Expected: JSON output of default config values.

Run: `./zoh auth login`
Expected: Error message about missing client_id/client_secret with helpful hint (not a crash).

Run: `go vet ./...` -- no errors.
  </verify>
  <done>
- `zoh auth login` prompts for OAuth2 flow (interactive or manual)
- `zoh auth login --manual` works without browser
- `zoh auth logout` removes stored credentials
- `zoh auth list` shows stored accounts, `--check` validates tokens
- `zoh config get KEY` retrieves config value
- `zoh config set KEY VALUE` saves config
- `zoh config unset KEY` removes config value
- `zoh config list` shows all config (masks secrets)
- `zoh config path` shows config file location
- All commands respect --json, --plain, --output flags
- Missing credentials produce helpful error with hint, not crash
- Exit codes correctly set for all error types
- `go build ./...` and `go vet ./...` pass clean
  </done>
</task>

</tasks>

<verification>
1. `go build -o zoh ./...` -- binary compiles
2. `./zoh --help` -- shows auth, config, version commands
3. `./zoh auth login` -- shows helpful error about missing client_id (not crash)
4. `./zoh config path` -- prints XDG-compliant config path
5. `./zoh config set region eu && ./zoh config get region` -- outputs "eu"
6. `./zoh config list` -- shows all config keys
7. `./zoh config list --json` -- outputs JSON to stdout
8. `./zoh auth list` -- shows stored accounts (empty on fresh install)
9. `go vet ./...` -- no warnings
10. Rate limiter configured for 25 req/min with burst 5
11. Exit codes used correctly (ExitAuth for auth errors, ExitConfigError for config issues)
</verification>

<success_criteria>
- Working auth login flow (both interactive and manual)
- Working auth logout that clears credentials
- Working auth list with --check for token validation
- Working config get/set/unset/list/path commands
- Region-aware HTTP client with OAuth2 transport
- Rate limiter respects 25 req/min budget
- All output modes (JSON, plain, rich) work for all commands
- Helpful error messages with hints when config is missing
- Correct exit codes for all error categories
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-03-SUMMARY.md`
</output>
