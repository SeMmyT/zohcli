---
phase: 06-cli-polish-power-user-ux
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/cli/globals.go
  - internal/cli/cli.go
  - internal/cli/schema.go
  - internal/cli/shortcuts.go
  - internal/output/formatter.go
autonomous: true

must_haves:
  truths:
    - "User can pass --results-only to strip JSON envelope and get raw data array"
    - "User can pass --no-input to disable prompts (commands fail instead of asking)"
    - "User can pass --force to skip destructive operation confirmations"
    - "User can pass --dry-run to preview mutating operations"
    - "--force and --dry-run cannot be used together (validation error)"
    - "User can run 'zoh send' as shortcut for 'zoh mail send compose'"
    - "User can run 'zoh ls users' as shortcut for 'zoh admin users list'"
    - "User can run 'zoh ls groups' as shortcut for 'zoh admin groups list'"
    - "User can run 'zoh ls folders' as shortcut for 'zoh mail folders list'"
    - "User can run 'zoh schema' to get full command tree as JSON"
    - "User can run 'zoh schema admin' to get subtree for admin commands"
  artifacts:
    - path: "internal/cli/globals.go"
      provides: "Scripting flags (ResultsOnly, NoInput, Force, DryRun) on Globals struct"
      contains: "ResultsOnly"
    - path: "internal/cli/cli.go"
      provides: "Desire-path shortcuts and schema command in CLI struct"
      contains: "LsCmd"
    - path: "internal/cli/schema.go"
      provides: "Schema introspection command implementation"
      exports: ["SchemaCmd", "SchemaNode"]
    - path: "internal/cli/shortcuts.go"
      provides: "LsCmd type with resource subcommands"
      exports: ["LsCmd"]
    - path: "internal/output/formatter.go"
      provides: "ResultsOnly filtering in JSON formatter"
      contains: "resultsOnly"
  key_links:
    - from: "internal/cli/globals.go"
      to: "internal/cli/cli.go"
      via: "Globals struct embedded in CLI"
      pattern: "Globals"
    - from: "internal/cli/cli.go"
      to: "internal/output/formatter.go"
      via: "BeforeApply creates formatter with resultsOnly"
      pattern: "ResultsOnly"
    - from: "internal/cli/schema.go"
      to: "kong.Context"
      via: "Run receives kong.Context for Node introspection"
      pattern: "ctx\\.Model\\.Node"
---

<objective>
Add global scripting flags (--results-only, --no-input, --force, --dry-run), desire-path shortcuts (zoh send, zoh ls), and machine-readable schema command (zoh schema) to the CLI root.

Purpose: Power users get the global flags and shortcuts that make zoh fast in interactive use and composable in scripts/pipelines.
Output: Updated globals.go, cli.go, new schema.go and shortcuts.go, updated formatter.go with results-only filtering.
</objective>

<execution_context>
@/home/semmy/.claude/get-shit-done/workflows/execute-plan.md
@/home/semmy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-cli-polish-power-user-ux/06-RESEARCH.md
@internal/cli/cli.go
@internal/cli/globals.go
@internal/output/formatter.go
@main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add scripting flags to Globals and results-only output filtering</name>
  <files>internal/cli/globals.go, internal/output/formatter.go, internal/cli/cli.go</files>
  <action>
1. In `internal/cli/globals.go`, add four new fields to the `Globals` struct:
   - `ResultsOnly bool` with tag `help:"Strip JSON envelope, return data array only" env:"ZOH_RESULTS_ONLY"`
   - `NoInput bool` with tag `help:"Disable interactive prompts (fail instead)" env:"ZOH_NO_INPUT"`
   - `Force bool` with tag `help:"Skip confirmation prompts for destructive operations" env:"ZOH_FORCE"`
   - `DryRun bool` with tag `help:"Preview operation without executing" name:"dry-run" env:"ZOH_DRY_RUN"`

2. In `internal/cli/cli.go` `BeforeApply`, add validation BEFORE formatter creation:
   - If `c.Force && c.DryRun` → return `fmt.Errorf("cannot use --force with --dry-run")` (force skips confirmation, dry-run needs to show what would happen — conflicting intent)
   - If `c.ResultsOnly && c.ResolvedOutput() != "json"` → return `fmt.Errorf("--results-only requires --output=json")` (results-only only makes sense for JSON output)

3. In `internal/output/formatter.go`:
   - Add `resultsOnly bool` field to `jsonFormatter` struct
   - Update `New()` to accept a variadic `opts ...Option` parameter using functional options pattern:
     ```go
     type Option func(*options)
     type options struct { resultsOnly bool }
     func WithResultsOnly(v bool) Option { return func(o *options) { o.resultsOnly = v } }
     ```
   - Or simpler: add `NewJSON(resultsOnly bool) Formatter` factory that returns `&jsonFormatter{resultsOnly: resultsOnly}`
   - Update `jsonFormatter.PrintList()`: when `resultsOnly` is true, encode items directly (skip envelope); when false, encode as-is (current behavior — note: current code already does `f.Print(items)` which just encodes items directly, so the current JSON formatter already returns raw data. The "envelope" behavior needs to be the NEW default, and resultsOnly strips it).
   - Actually, looking at current code: `PrintList` just calls `f.Print(items)` which encodes raw. This means there IS no envelope currently. The requirement says `--results-only` strips envelope. So we need to:
     a. Add envelope wrapping as the default for JSON PrintList: `{"data": items, "count": N}`
     b. When `resultsOnly=true`, return raw array (current behavior)
   - Update `jsonFormatter.Print()` (single object): when `resultsOnly` is true, pass through (no change for single objects)

4. In `internal/cli/cli.go` `BeforeApply`, update formatter creation:
   - When output mode is "json", create formatter with `output.NewJSON(c.ResultsOnly)`
   - When output mode is not "json", use `output.New(mode)` as before
  </action>
  <verify>
Run `go build ./...` — project compiles with new flags and formatter changes. Run `go vet ./...` — no issues.
  </verify>
  <done>
Globals struct has ResultsOnly, NoInput, Force, DryRun fields. BeforeApply validates --force/--dry-run conflict and --results-only/--output conflict. JSON formatter wraps lists in `{"data": [...], "count": N}` envelope by default and strips it when resultsOnly=true.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add desire-path shortcuts and schema introspection command</name>
  <files>internal/cli/shortcuts.go, internal/cli/schema.go, internal/cli/cli.go</files>
  <action>
1. Create `internal/cli/shortcuts.go` with:
   - `LsCmd` struct with subcommands:
     ```go
     type LsCmd struct {
         Users   AdminUsersListCmd  `cmd:"" help:"List users (shortcut for admin users list)"`
         Groups  AdminGroupsListCmd `cmd:"" help:"List groups (shortcut for admin groups list)"`
         Folders MailFoldersListCmd `cmd:"" help:"List folders (shortcut for mail folders list)"`
         Labels  MailLabelsListCmd  `cmd:"" help:"List labels (shortcut for mail labels list)"`
     }
     ```
   - These reuse existing command types, so Run() implementations are already defined. No code duplication.

2. Create `internal/cli/schema.go` with:
   - `SchemaCmd` struct:
     ```go
     type SchemaCmd struct {
         Command string `arg:"" optional:"" help:"Command path to show schema for (e.g., 'admin users')"`
     }
     ```
   - `SchemaNode` struct for JSON output:
     ```go
     type SchemaNode struct {
         Name     string                 `json:"name"`
         Type     string                 `json:"type"`     // "application", "command", "argument"
         Help     string                 `json:"help,omitempty"`
         Aliases  []string               `json:"aliases,omitempty"`
         Hidden   bool                   `json:"hidden,omitempty"`
         Children []*SchemaNode          `json:"commands,omitempty"`
         Flags    []*SchemaFlag          `json:"flags,omitempty"`
         Args     []*SchemaArg           `json:"args,omitempty"`
     }
     type SchemaFlag struct {
         Name     string   `json:"name"`
         Help     string   `json:"help,omitempty"`
         Type     string   `json:"type"`
         Required bool     `json:"required,omitempty"`
         Default  string   `json:"default,omitempty"`
         Enum     []string `json:"enum,omitempty"`
         Short    rune     `json:"short,omitempty"`
         Env      string   `json:"env,omitempty"`
     }
     type SchemaArg struct {
         Name     string `json:"name"`
         Help     string `json:"help,omitempty"`
         Required bool   `json:"required,omitempty"`
     }
     ```
   - `func (cmd *SchemaCmd) Run(ctx *kong.Context) error` — traverses Kong's `ctx.Model.Node` tree:
     - If `cmd.Command` is empty, build schema from root node
     - If `cmd.Command` is provided, split on spaces and walk `node.Children` to find the target, return error if not found
     - Build `SchemaNode` recursively from `*kong.Node`: name, type (ApplicationNode/CommandNode/ArgumentNode), help, aliases
     - Extract flags from `node.Flags` (skip hidden system flags like `--help`): name, help, required, default, enum values, short flag, env var
     - Extract positional args from `node.Positional`: name, help, required
     - Recurse into `node.Children` for sub-commands
     - Encode to stdout with `json.NewEncoder(os.Stdout).SetIndent("", "  ")`
   - Helper `func buildSchemaNode(node *kong.Node) *SchemaNode`
   - Helper `func findNodeByPath(root *kong.Node, path string) *kong.Node`

3. In `internal/cli/cli.go`, add to CLI struct (AFTER existing commands, BEFORE Version):
   ```go
   // Desire-path shortcuts
   Send   MailSendComposeCmd `cmd:"" help:"Send an email (shortcut for mail send compose)" hidden:""`
   Ls     LsCmd             `cmd:"" help:"List resources (users, groups, folders, labels)" hidden:""`

   // Introspection
   Schema SchemaCmd `cmd:"" help:"Show machine-readable command tree as JSON"`
   ```
   - Mark Send and Ls as `hidden:""` so they don't clutter the main help output but are still functional. Users discover them via docs or schema command.
   - Note: Kong `hidden:""` tag hides from help but command still works.
  </action>
  <verify>
Run `go build ./...` — compiles. Run `go vet ./...` — no issues. Run `go run . schema 2>&1 | head -20` — outputs JSON schema of command tree. Run `go run . ls --help` — shows users/groups/folders/labels subcommands. Run `go run . send --help` — shows compose email flags.
  </verify>
  <done>
`zoh send` works as shortcut for `zoh mail send compose`. `zoh ls users/groups/folders/labels` works as shortcuts. `zoh schema` outputs full command tree as JSON. `zoh schema admin` outputs admin subtree. Shortcuts are hidden from main help to keep it clean.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `go vet ./...` passes
3. `go run . --help` shows existing commands plus Schema (shortcuts hidden)
4. `go run . schema | python3 -m json.tool` validates JSON output
5. `go run . schema admin` shows admin subtree
6. `go run . ls --help` shows users, groups, folders, labels
7. `go run . send --help` shows compose email flags
8. `go run . --results-only --output=plain` returns error about requiring --output=json
9. `go run . --force --dry-run admin users list` returns error about conflicting flags
</verification>

<success_criteria>
- Four scripting flags available on every command via Globals
- Flag validation prevents conflicting combinations
- JSON output wraps lists in envelope by default; --results-only strips it
- Desire-path shortcuts work: `zoh send`, `zoh ls users`, `zoh ls groups`, `zoh ls folders`, `zoh ls labels`
- Schema command outputs machine-readable JSON for full tree or any subtree
</success_criteria>

<output>
After completion, create `.planning/phases/06-cli-polish-power-user-ux/06-01-SUMMARY.md`
</output>
